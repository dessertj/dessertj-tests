package de.spricom.dessert.tools;

import de.spricom.dessert.classfile.ClassFile;
import de.spricom.dessert.classfile.attribute.Attributes;
import de.spricom.dessert.classfile.attribute.ModuleAttribute;
import de.spricom.dessert.classfile.attribute.ModulePackagesAttribute;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.*;
import java.lang.invoke.MethodHandles;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * Utility to create module slices to be used together with jQAssistant.
 */
public class GenerateModulesCypherTool {
    private Logger log = Logger.getLogger(MethodHandles.lookup().lookupClass().getName());

    // -Dtarget.src.dir=C:\Code\git\dessert\dessert-core\src\main\java
    private static final String SRC = System.getProperty("target.src.dir", "target/generated-sources");
    private static final Path DIR = Path.of(SRC, "de.spricom.dessert.modules".split("\\."));

    private PrintWriter out;
    private FileSystem jrt;
    private final SortedMap<String, ModuleDef> modules = new TreeMap<>();
    private final SortedMap<String, Node> moduleNames = new TreeMap<>();
    private final SortedMap<String, Node> packageNames = new TreeMap<>();
    private final String generatedBy = "/**\n" +
            " * Generated by " + this.getClass().getName()+ ".\n" +
            " */";

    @BeforeEach
    void init() throws IOException {
        jrt = FileSystems.newFileSystem(URI.create("jrt:/"), Collections.emptyMap());
        scanModules();
    }

    @Test
    void generateFixedModules() throws IOException {
        createModules();
    }

    private void createModules() throws IOException {
        File file = new File("target", "JavaModules.txt");
        try (OutputStreamWriter w = new OutputStreamWriter(
                new FileOutputStream(file), StandardCharsets.UTF_8)) {
            for (ModuleDef module : modules.values()) {
                if (module.name.startsWith("java.")) {
                    w.write(renderModule(module));
                    System.out.printf("        <includeConcept refId=\"slices:JavaRuntime:%s\"/>%n",
                            module.fileName());
                }
            }
        }
    }

    private String renderModule(ModuleDef moduleDef) {
        return """
                    <concept id="slices:JavaRuntime:%1$s">
                        <description>Define slice for java-runtime module %2$s version %3$s.</description>
                        <cypher><![CDATA[
                            MATCH (c:Java:Type)
                            %4$s
                            MERGE (s:Slice:JavaRuntime {name: '%1$s'})
                            MERGE (c)-[:BELONGS_TO]->(s)
                            RETURN s
                        ]]></cypher>
                    </concept>
                    
                """.formatted(
                moduleDef.fileName(),
                moduleDef.name,
                moduleDef.version,
                renderSlice(moduleDef.exported)
        );
    }

    private String renderSlice(SortedSet<String> packages) {
        return packages.stream()
                .map(s -> "c.fqn STARTS WITH '" + s + "'")
                .collect(Collectors.joining("\n               OR ", "WHERE ", ""));
    }

    private void scanModules() throws IOException {
        Path modules = jrt.getPath("/modules");
        DirectoryStream<Path> paths = Files.newDirectoryStream(modules);
        for (Path path : paths) {
            if (Files.isDirectory(path)) {
                scanModule(path);
            }
        }
    }

    private void scanModule(Path modulePath) throws IOException {
        Path moduleInfoPath = modulePath.resolve("module-info.class");
        assert Files.isRegularFile(moduleInfoPath) : "There is no " + moduleInfoPath + " file!";
        try (InputStream is = Files.newInputStream(moduleInfoPath, StandardOpenOption.READ)) {
            ClassFile cf = new ClassFile(is);
            List<ModuleAttribute> moduleAttributes = Attributes.filter(cf.getAttributes(), ModuleAttribute.class);
            assert moduleAttributes.size() == 1 : "There are " + moduleAttributes.size() + " module attibutes in " + moduleInfoPath;
            ModuleAttribute moduleAttribute = moduleAttributes.get(0);

            ModuleDef module = new ModuleDef();
            module.name = moduleAttribute.getModuleName();
            module.version = moduleAttribute.getModuleVersion();

            for (ModuleAttribute.Export export : moduleAttribute.getExports()) {
                if (export.isUnqualified()) {
                    module.exported.add(export.getPackageName());
                }
            }

            List<ModulePackagesAttribute> modulePackagesAttributes = Attributes.filter(cf.getAttributes(), ModulePackagesAttribute.class);
            if (!modulePackagesAttributes.isEmpty()) {
                ModulePackagesAttribute modulePackagesAttribute = modulePackagesAttributes.get(0);
                module.packages.addAll(Arrays.asList(modulePackagesAttribute.getPackageNames()));
            }
            modules.put(module.name, module);
            addName(moduleNames, module.name);
        }
    }

    private void addName(SortedMap<String, Node> names, String fullName) {
        String[] parts = fullName.split("\\.");
        String name = "";
        Node parent = names.computeIfAbsent(name, n -> new Node(null, n));
        for (String part : parts) {
            name += part;
            Node node = names.get(name);
            if (node == null) {
                node = new Node(parent, part);
                names.put(name, node);
            }
            parent = node;
            name += ".";
        }
    }

    static class ModuleDef {
        String name;
        String version;
        final SortedSet<String> exported = new TreeSet<>();
        final SortedSet<String> packages = new TreeSet<>();

        String variableName() {
            return name.substring(name.indexOf(".") + 1);
        }

        String dirName() {
            return name.substring(0, name.indexOf("."));
        }

        String fileName() {
            String[] parts = name.split("\\.");
            StringBuilder sb = new StringBuilder();
            for (int i = 1; i < parts.length; i++) {
                sb.append(Character.toUpperCase(parts[i].charAt(0))).append(parts[i].substring(1));
            }
            return sb.toString();
        }
    }

    static class Node {
        final Node parent;
        final String name;
        final SortedMap<String, Node> children = new TreeMap<>();

        Node(Node parent, String name) {
            this.parent = parent;
            this.name = name;
            if (parent != null) {
                parent.children.put(this.name, this);
            }
        }

        String fullName() {
            return parent == null || parent.parent == null ? name : parent.fullName() + "." + name;
        }
    }
}
